%
% API Documentation for Peach - Computational Intelligence for Python
% Module peach.optm.quasinewton
%
% Generated by epydoc 3.0.1
% [Mon Jan 24 15:39:52 2011]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.quasinewton \textit{(module)}|(}
\section{Module peach.optm.quasinewton}

    \label{peach:optm:quasinewton}

This package implements basic quasi-Newton optimizers. Newton optimizer is very
efficient, except that inverse matrices need to be calculated at each
convergence step. These methods try to estimate the hessian inverse iteratively,
thus increasing performance.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-d\-o\-c\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{...}}&\\
\cline{1-2}
\raggedright \_\-\_\-p\-a\-c\-k\-a\-g\-e\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{peach.optm}\texttt{'}}&\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.quasinewton \textit{(module)}!peach.optm.quasinewton.DFP \textit{(class)}|(}
\subsection{Class DFP}

    \label{peach:optm:quasinewton:DFP}
\begin{tabular}{cccccccc}
% Line for object, linespec=[False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for peach.optm.base.Optimizer, linespec=[False]
\multicolumn{4}{r}{\settowidth{\BCL}{peach.optm.base.Optimizer}\multirow{2}{\BCL}{peach.optm.base.Optimizer}}
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&\multicolumn{2}{l}{\textbf{peach.optm.quasinewton.DFP}}
\end{tabular}


DFP (\emph{Davidon-Fletcher-Powell}) search

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{f}, \textit{x0}, \textit{ranges}={\tt None}, \textit{df}={\tt None}, \textit{h}={\tt 0.1}, \textit{emax}={\tt 1e-08}, \textit{imax}={\tt 1000})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

Initializes the optimizer.

To create an optimizer of this type, instantiate the class with the
parameters given below:
\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxxxx}

          \item[f]


A multivariable function to be optimized. The function should have
only one parameter, a multidimensional line-vector, and return the
function value, a scalar.
          \item[x0]


First estimate of the minimum. Estimates can be given in any format,
but internally they are converted to a one-dimension vector, where
each component corresponds to the estimate of that particular
variable. The vector is computed by flattening the array.
          \item[ranges]


A range of values might be passed to the algorithm, but it is not
necessary. If supplied, this parameter should be a list of ranges
for each variable of the objective function. It is specified as a
list of tuples of two values, \texttt{(x0, x1)}, where \texttt{x0} is the
start of the interval, and \texttt{x1} its end. Obviously, \texttt{x0} should
be smaller than \texttt{x1}. It can also be given as a list with a simple
tuple in the same format. In that case, the same range will be
applied for every variable in the optimization.
          \item[df]


A function to calculate the gradient vector of the cost function
\texttt{f}. Defaults to \texttt{None}, if no gradient is supplied, then it is
estimated from the cost function using Euler equations.
          \item[h]


Convergence step. This method does not takes into consideration the
possibility of varying the convergence step, to avoid Stiefel cages.
          \item[emax]


Maximum allowed error. The algorithm stops as soon as the error is
below this level. The error is absolute.
          \item[imax]


Maximum number of iterations, the algorithm stops as soon this
number of iterations are executed, no matter what the error is at
the moment.
        \end{Ventry}

      \end{quote}

      Overrides: object.\_\_init\_\_

    \end{boxedminipage}

    \label{peach:optm:quasinewton:DFP:restart}
    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.quasinewton \textit{(module)}!peach.optm.quasinewton.DFP \textit{(class)}!peach.optm.quasinewton.DFP.restart \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{restart}(\textit{self}, \textit{x0}, \textit{h}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

Resets the optimizer, returning to its original state, and allowing to
use a new first estimate.
\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xx}

          \item[x0]


New estimate of the minimum. Estimates can be given in any format,
but internally they are converted to a one-dimension vector, where
each component corresponds to the estimate of that particular
variable. The vector is computed by flattening the array.
          \item[h]


Convergence step. This method does not takes into consideration the
possibility of varying the convergence step, to avoid Stiefel cages.
        \end{Ventry}

      \end{quote}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{step}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

One step of the search.

In this method, the result of the step is dependent of parameters
calculated before (namely, the estimate of the inverse hessian), so it
is not recomended that different investigations are used with the same
optimizer in the same cost function.
\setlength{\parskip}{1ex}
      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}

This method returns a tuple \texttt{(x, e)}, where \texttt{x} is the updated
estimate of the minimum, and \texttt{e} is the estimated error.
      \end{quote}

      Overrides: peach.optm.base.Optimizer.step

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_call\_\_}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

Transparently executes the search until the minimum is found. The stop
criteria are the maximum error or the maximum number of iterations,
whichever is reached first. Note that this is a \texttt{\_\_call\_\_} method, so
the object is called as a function. This method returns a tuple
\texttt{(x, e)}, with the best estimate of the minimum and the error.
\setlength{\parskip}{1ex}
      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}

This method returns a tuple \texttt{(x, e)}, where \texttt{x} is the best
estimate of the minimum, and \texttt{e} is the estimated error.
      \end{quote}

      Overrides: peach.optm.base.Optimizer.\_\_call\_\_

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_repr\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright x\- & &\\
\cline{1-2}
\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Instance Variables                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Instance Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright r\-a\-n\-g\-e\-s\- & Holds the ranges for every variable. Although it is a writable
property, care should be taken in changing parameters before ending the
convergence.&\\
\cline{1-2}
\end{longtable}

    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.quasinewton \textit{(module)}!peach.optm.quasinewton.DFP \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.quasinewton \textit{(module)}!peach.optm.quasinewton.BFGS \textit{(class)}|(}
\subsection{Class BFGS}

    \label{peach:optm:quasinewton:BFGS}
\begin{tabular}{cccccccc}
% Line for object, linespec=[False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for peach.optm.base.Optimizer, linespec=[False]
\multicolumn{4}{r}{\settowidth{\BCL}{peach.optm.base.Optimizer}\multirow{2}{\BCL}{peach.optm.base.Optimizer}}
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&\multicolumn{2}{l}{\textbf{peach.optm.quasinewton.BFGS}}
\end{tabular}


BFGS (\emph{Broyden-Fletcher-Goldfarb-Shanno}) search

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{f}, \textit{x0}, \textit{ranges}={\tt None}, \textit{df}={\tt None}, \textit{h}={\tt 0.1}, \textit{emax}={\tt 1e-05}, \textit{imax}={\tt 1000})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

Initializes the optimizer.

To create an optimizer of this type, instantiate the class with the
parameters given below:
\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxxxx}

          \item[f]


A multivariable function to be optimized. The function should have
only one parameter, a multidimensional line-vector, and return the
function value, a scalar.
          \item[x0]


First estimate of the minimum. Estimates can be given in any format,
but internally they are converted to a one-dimension vector, where
each component corresponds to the estimate of that particular
variable. The vector is computed by flattening the array.
          \item[ranges]


A range of values might be passed to the algorithm, but it is not
necessary. If supplied, this parameter should be a list of ranges
for each variable of the objective function. It is specified as a
list of tuples of two values, \texttt{(x0, x1)}, where \texttt{x0} is the
start of the interval, and \texttt{x1} its end. Obviously, \texttt{x0} should
be smaller than \texttt{x1}. It can also be given as a list with a simple
tuple in the same format. In that case, the same range will be
applied for every variable in the optimization.
          \item[df]


A function to calculate the gradient vector of the cost function
\texttt{f}. Defaults to \texttt{None}, if no gradient is supplied, then it is
estimated from the cost function using Euler equations.
          \item[h]


Convergence step. This method does not takes into consideration the
possibility of varying the convergence step, to avoid Stiefel cages.
          \item[emax]


Maximum allowed error. The algorithm stops as soon as the error is
below this level. The error is absolute.
          \item[imax]


Maximum number of iterations, the algorithm stops as soon this
number of iterations are executed, no matter what the error is at
the moment.
        \end{Ventry}

      \end{quote}

      Overrides: object.\_\_init\_\_

    \end{boxedminipage}

    \label{peach:optm:quasinewton:BFGS:restart}
    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.quasinewton \textit{(module)}!peach.optm.quasinewton.BFGS \textit{(class)}!peach.optm.quasinewton.BFGS.restart \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{restart}(\textit{self}, \textit{x0}, \textit{h}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

Resets the optimizer, returning to its original state, and allowing to
use a new first estimate.
\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xx}

          \item[x0]


New estimate of the minimum. Estimates can be given in any format,
but internally they are converted to a one-dimension vector, where
each component corresponds to the estimate of that particular
variable. The vector is computed by flattening the array.
          \item[h]


Convergence step. This method does not takes into consideration the
possibility of varying the convergence step, to avoid Stiefel cages.
        \end{Ventry}

      \end{quote}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{step}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

One step of the search.

In this method, the result of the step is dependent of parameters
calculated before (namely, the estimate of the inverse hessian), so it
is not recomended that different investigations are used with the same
optimizer in the same cost function.
\setlength{\parskip}{1ex}
      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}

This method returns a tuple \texttt{(x, e)}, where \texttt{x} is the updated
estimate of the minimum, and \texttt{e} is the estimated error.
      \end{quote}

      Overrides: peach.optm.base.Optimizer.step

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_call\_\_}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

Transparently executes the search until the minimum is found. The stop
criteria are the maximum error or the maximum number of iterations,
whichever is reached first. Note that this is a \texttt{\_\_call\_\_} method, so
the object is called as a function. This method returns a tuple
\texttt{(x, e)}, with the best estimate of the minimum and the error.
\setlength{\parskip}{1ex}
      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}

This method returns a tuple \texttt{(x, e)}, where \texttt{x} is the best
estimate of the minimum, and \texttt{e} is the estimated error.
      \end{quote}

      Overrides: peach.optm.base.Optimizer.\_\_call\_\_

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_repr\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Instance Variables                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Instance Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright r\-a\-n\-g\-e\-s\- & Holds the ranges for every variable. Although it is a writable
property, care should be taken in changing parameters before ending the
convergence.&\\
\cline{1-2}
\end{longtable}

    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.quasinewton \textit{(module)}!peach.optm.quasinewton.BFGS \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.quasinewton \textit{(module)}!peach.optm.quasinewton.SR1 \textit{(class)}|(}
\subsection{Class SR1}

    \label{peach:optm:quasinewton:SR1}
\begin{tabular}{cccccccc}
% Line for object, linespec=[False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for peach.optm.base.Optimizer, linespec=[False]
\multicolumn{4}{r}{\settowidth{\BCL}{peach.optm.base.Optimizer}\multirow{2}{\BCL}{peach.optm.base.Optimizer}}
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&\multicolumn{2}{l}{\textbf{peach.optm.quasinewton.SR1}}
\end{tabular}


SR1 (\emph{Symmetric Rank 1} ) search method

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{f}, \textit{x0}, \textit{ranges}={\tt None}, \textit{df}={\tt None}, \textit{h}={\tt 0.1}, \textit{emax}={\tt 1e-05}, \textit{imax}={\tt 1000})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

Initializes the optimizer.

To create an optimizer of this type, instantiate the class with the
parameters given below:
\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxxxx}

          \item[f]


A multivariable function to be optimized. The function should have
only one parameter, a multidimensional line-vector, and return the
function value, a scalar.
          \item[x0]


First estimate of the minimum. Estimates can be given in any format,
but internally they are converted to a one-dimension vector, where
each component corresponds to the estimate of that particular
variable. The vector is computed by flattening the array.
          \item[ranges]


A range of values might be passed to the algorithm, but it is not
necessary. If supplied, this parameter should be a list of ranges
for each variable of the objective function. It is specified as a
list of tuples of two values, \texttt{(x0, x1)}, where \texttt{x0} is the
start of the interval, and \texttt{x1} its end. Obviously, \texttt{x0} should
be smaller than \texttt{x1}. It can also be given as a list with a simple
tuple in the same format. In that case, the same range will be
applied for every variable in the optimization.
          \item[df]


A function to calculate the gradient vector of the cost function
\texttt{f}. Defaults to \texttt{None}, if no gradient is supplied, then it is
estimated from the cost function using Euler equations.
          \item[h]


Convergence step. This method does not takes into consideration the
possibility of varying the convergence step, to avoid Stiefel cages.
          \item[emax]


Maximum allowed error. The algorithm stops as soon as the error is
below this level. The error is absolute.
          \item[imax]


Maximum number of iterations, the algorithm stops as soon this
number of iterations are executed, no matter what the error is at
the moment.
        \end{Ventry}

      \end{quote}

      Overrides: object.\_\_init\_\_

    \end{boxedminipage}

    \label{peach:optm:quasinewton:SR1:restart}
    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.quasinewton \textit{(module)}!peach.optm.quasinewton.SR1 \textit{(class)}!peach.optm.quasinewton.SR1.restart \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{restart}(\textit{self}, \textit{x0}, \textit{h}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

Resets the optimizer, returning to its original state, and allowing to
use a new first estimate.
\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xx}

          \item[x0]


New estimate of the minimum. Estimates can be given in any format,
but internally they are converted to a one-dimension vector, where
each component corresponds to the estimate of that particular
variable. The vector is computed by flattening the array.
          \item[h]


Convergence step. This method does not takes into consideration the
possibility of varying the convergence step, to avoid Stiefel cages.
        \end{Ventry}

      \end{quote}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{step}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

One step of the search.

In this method, the result of the step is dependent of parameters
calculated before (namely, the estimate of the inverse hessian), so it
is not recomended that different investigations are used with the same
optimizer in the same cost function.
\setlength{\parskip}{1ex}
      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}

This method returns a tuple \texttt{(x, e)}, where \texttt{x} is the updated
estimate of the minimum, and \texttt{e} is the estimated error.
      \end{quote}

      Overrides: peach.optm.base.Optimizer.step

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_call\_\_}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}

Transparently executes the search until the minimum is found. The stop
criteria are the maximum error or the maximum number of iterations,
whichever is reached first. Note that this is a \texttt{\_\_call\_\_} method, so
the object is called as a function. This method returns a tuple
\texttt{(x, e)}, with the best estimate of the minimum and the error.
\setlength{\parskip}{1ex}
      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}

This method returns a tuple \texttt{(x, e)}, where \texttt{x} is the best
estimate of the minimum, and \texttt{e} is the estimated error.
      \end{quote}

      Overrides: peach.optm.base.Optimizer.\_\_call\_\_

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_repr\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright x\- & &\\
\cline{1-2}
\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Instance Variables                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Instance Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright r\-a\-n\-g\-e\-s\- & Holds the ranges for every variable. Although it is a writable
property, care should be taken in changing parameters before ending the
convergence.&\\
\cline{1-2}
\end{longtable}

    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.quasinewton \textit{(module)}!peach.optm.quasinewton.SR1 \textit{(class)}|)}
    \index{peach \textit{(package)}!peach.optm \textit{(package)}!peach.optm.quasinewton \textit{(module)}|)}
